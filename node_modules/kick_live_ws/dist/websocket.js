"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketConnection = void 0;
const ws_1 = __importDefault(require("ws"));
const events_1 = require("events");
const kick_1 = require("./api-routes/kick");
const userAPI_1 = require("./fetch/userAPI");
;
function generateSubscribeEventChatrooms(chatroomName) {
    const subscribeEvent = {
        "event": "pusher:subscribe",
        "data": {
            "auth": "",
            "channel": `chatrooms.${chatroomName}.v2`
        }
    };
    return subscribeEvent;
}
function generateSubscribeEventChannel(channelName) {
    const subscribeEvent = { "event": "pusher:subscribe", "data": { "auth": "", "channel": `channel.${channelName}` } };
    return subscribeEvent;
}
class WebSocketConnection extends events_1.EventEmitter {
    addListenerTypes() {
        this.wsConnection.onclose = () => {
            this.connected = false;
            this.emit("disconnect" /* MessageEvents.DISCONNECT */, 'disconnected');
        };
        this.wsConnection.onmessage = (event) => {
            this.emit("everything" /* MessageEvents.EVERYTHING */, event);
            const websocket_message = JSON.parse(String(event.data));
            switch (websocket_message.event) {
                case 'App\\Events\\ChatMessageEvent':
                    this.emit("chat" /* MessageEvents.CHATMESSAGE */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\FollowersUpdated':
                    this.emit("followerupdate" /* MessageEvents.FOLLOWERUPDATE */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\UserBannedEvent':
                    this.emit("ban" /* MessageEvents.BAN */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\UserUnbannedEvent':
                    this.emit("unban" /* MessageEvents.UNBAN */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\SubscriptionEvent':
                    this.emit("subscriptionevent" /* MessageEvents.SUBSCRIPTIONEVENT */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\ChannelSubscriptionEvent':
                    this.emit("channelsubscription" /* MessageEvents.CHANNELSUBSCRIPTION */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\GiftedSubscriptionsEvent':
                    this.emit("giftedsubscription" /* MessageEvents.GIFTEDSUBSCRIPTION */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\LuckyUsersWhoGotGiftSubscriptionsEvent':
                    this.emit("luckyuserswhogotgiftsubscriptions" /* MessageEvents.LUCKYUSERSWHOGOTGIFTSUBSCRIPTIONS */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\GiftsLeaderboardUpdated':
                    this.emit("giftsleaderboardupdated" /* MessageEvents.GIFTSLEADERBOARDUPDATED */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\MessageDeletedEvent':
                    this.emit("messagedelete" /* MessageEvents.MESSEAGEDELETE */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\StreamerIsLive':
                    this.emit("streamstart" /* MessageEvents.STREAMSTART */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\StopStreamBroadcast':
                    this.emit("stopstream" /* MessageEvents.STOPSTREAM */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\ChatroomUpdatedEvent':
                    this.emit("chatroomupdated" /* MessageEvents.CHATROOMUPDATED */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\StreamHostEvent':
                    this.emit("streamhost" /* MessageEvents.STREAMHOST */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\PinnedMessageCreatedEvent':
                    this.emit("pinnedmessagecreated" /* MessageEvents.PINNEDMESSAGECREATED */, JSON.parse(websocket_message.data));
                    break;
                case 'App\\Events\\PinnedMessageDeletedEvent':
                    this.emit("pinnedmessagedeleted" /* MessageEvents.PINNEDMESSAGEDELETED */, JSON.parse(websocket_message.data));
                    break;
                case 'pusher:error':
                    this.emit("error" /* MessageEvents.ERROR */, event);
                    break;
                case 'pusher_internal:subscription_succeeded':
                    this.emit("connected" /* MessageEvents.CONNECTED */, event);
                    break;
                default:
                    this.emit("untracked" /* MessageEvents.UNTRACKED */, event);
                    break;
            }
        };
    }
    constructor({ name, chatroom_id, channel_id }) {
        super();
        this.connected = false;
        this.channelName = '';
        this.chatroomName = '';
        this.chatroom_id = '';
        this.channel_id = '';
        this.name = name;
        this.chatroom_id = chatroom_id !== undefined ? chatroom_id : '';
        this.channel_id = channel_id !== undefined ? channel_id : '';
        this.wsConnection = new ws_1.default('wss://ws-us2.pusher.com/app/eb1d5f283081a78b932c?protocol=7&client=js&version=7.6.0&flash=false');
        this.wsConnection.onopen = (event) => {
            this.addListenerTypes();
        };
        this.wsConnection.onerror = (error) => {
            this.connected = false;
            this.emit("error" /* MessageEvents.ERROR */, 'error');
            console.log('disconnected from websocket due to error', error);
        };
        this.addListenerTypes();
    }
    connectWebSocket() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.wsConnection = new ws_1.default('wss://ws-us2.pusher.com/app/eb1d5f283081a78b932c?protocol=7&client=js&version=7.6.0&flash=false');
                this.wsConnection.onopen = (event) => {
                    console.log('WebSocket connected successfully');
                    this.addListenerTypes();
                    resolve(event); // Resolve the promise as the connection and listener setup was successful
                };
                this.wsConnection.onerror = (error) => {
                    this.connected = false;
                    this.emit("error" /* MessageEvents.ERROR */, 'error');
                    console.log('disconnected from websocket due to error', error);
                    reject(error); // Reject the promise if there was an error during connection setup
                };
            });
        });
    }
    getIds() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const websiteUrl = kick_1.CHANNEL + this.name;
                    const json_data = yield (0, userAPI_1.scrapeWebsite)(websiteUrl);
                    this.channelName = json_data.chatroom.channel_id;
                    this.chatroomName = json_data.chatroom.id;
                    resolve(json_data); // Resolves the Promise when the asynchronous operation is completed
                }
                catch (error) {
                    console.log('error get ids', error);
                    this.emit("disconnect" /* MessageEvents.DISCONNECT */, "can not get ids");
                    reject(error); // Rejects the Promise if an error occurs during the asynchronous operation
                }
            }));
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.connected === true) {
                    console.log('"Already connected"');
                    throw new Error("Already connected");
                }
                if (this.channel_id === '' && this.chatroom_id === '') {
                    yield this.getIds();
                }
                if (this.wsConnection.readyState === ws_1.default.OPEN && this.connected === false) {
                    try {
                        if (this.channel_id === '' && this.chatroom_id === '') {
                            this.wsConnection.send(JSON.stringify(generateSubscribeEventChannel(this.channelName)));
                            this.wsConnection.send(JSON.stringify(generateSubscribeEventChatrooms(this.chatroomName)));
                        }
                        else {
                            this.wsConnection.send(JSON.stringify(generateSubscribeEventChannel(this.channel_id)));
                            this.wsConnection.send(JSON.stringify(generateSubscribeEventChatrooms(this.chatroom_id)));
                        }
                        this.connected = true;
                        console.log('listening to chat');
                    }
                    catch (err) {
                        throw new Error("Error while sending subscription events");
                    }
                }
                if (this.wsConnection.readyState === ws_1.default.CONNECTING || this.wsConnection.readyState === ws_1.default.CLOSING) {
                    throw new Error("Connecting, try later");
                }
                if (this.wsConnection.readyState === ws_1.default.CLOSED) {
                    try {
                        yield this.connectWebSocket();
                        this.wsConnection.send(JSON.stringify(generateSubscribeEventChannel(this.channelName)));
                        this.wsConnection.send(JSON.stringify(generateSubscribeEventChatrooms(this.chatroomName)));
                    }
                    catch (error) {
                        console.error('Failed to connect to WebSocket:', error);
                        // Handle den Fehler entsprechend
                    }
                }
            }
            catch (error) {
                this.emit('errorEvent', error);
            }
        });
    }
}
exports.WebSocketConnection = WebSocketConnection;
